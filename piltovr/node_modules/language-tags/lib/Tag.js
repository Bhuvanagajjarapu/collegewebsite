/**
 * @author Matthew Caruana Galizia <mattcg@gmail.com>
 * @license MIT: http://mattcg.mit-license.org/
 * @copyright Copyright (c) 2013, Matthew Caruana Galizia
 */

'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var index = require('language-subtag-registry/data/json/index.json');
var registry = require('language-subtag-registry/data/json/registry.json');
var Subtag = require('./Subtag.js');
var Tag = /*#__PURE__*/function () {
  /** @param {string} tag */
  function Tag(tag) {
    _classCallCheck(this, Tag);
    var types;

    // Lowercase for consistency (case is only a formatting convention, not a standard requirement).
    tag = tag.trim().toLowerCase();
    this.data = {
      tag: tag
    };

    // Check if the input tag is grandfathered or redundant.
    types = index[tag];
    if (types && (types.grandfathered || types.redundant)) {
      this.data.record = registry[types.grandfathered || types.redundant];
    }
  }
  _createClass(Tag, [{
    key: "preferred",
    value: function preferred() {
      var preferred = this.data.record['Preferred-Value'];
      if (preferred) {
        return new Tag(preferred);
      }
      return null;
    }

    /** @return {Subtag[]} */
  }, {
    key: "subtags",
    value: function subtags() {
      var codes,
        data = this.data,
        subtags = [];

      // No subtags if the tag is grandfathered.
      if (data.record && this.type() === 'grandfathered') {
        return subtags;
      }
      codes = data.tag.split('-');
      if (!codes.length) {
        return subtags;
      }

      // Try and find the language tag.
      codes.some(function (code, i) {
        var types;

        // Singletons and anything after are unhandled.
        if (code.length < 2) {
          return true; // Stop the loop (stop processing after a singleton).
        }

        types = index[code];

        // Check for non-existent tag.
        if (!types) {
          return; // Skip to the next item.
        }

        // Check against undefined because value could be 0.
        // Language subtags may only appear at the beginning of the tag, otherwise the subtag type is indeterminate.
        if (0 === i && undefined !== types.language) {
          subtags.push(new Subtag(code, 'language'));
          return;
        }
        switch (code.length) {
          case 2:
            // Should be a region.
            if (types.region) {
              subtags.push(new Subtag(code, 'region'));

              // Error case: language subtag in the wrong place.
            } else if (types.language) {
              subtags.push(new Subtag(code, 'language'));
            }
            break;
          case 3:
            // Could be a numeric region code e.g. '001' for 'World'.
            if (types.region) {
              subtags.push(new Subtag(code, 'region'));
            } else if (types.extlang) {
              subtags.push(new Subtag(code, 'extlang'));

              // Error case: language subtag in the wrong place.
            } else if (types.language) {
              subtags.push(new Subtag(code, 'language'));
            }
            break;
          case 4:
            // Could be a numeric variant.
            if (types.variant) {
              subtags.push(new Subtag(code, 'variant'));
            } else if (types.script) {
              subtags.push(new Subtag(code, 'script'));
            }
            break;
          default:
            // Should be a variant.
            if (types.variant) {
              subtags.push(new Subtag(code, 'variant'));
            }
            break;
        }
      });
      return subtags;
    }
  }, {
    key: "language",
    value: function language() {
      return this.find('language');
    }
  }, {
    key: "region",
    value: function region() {
      return this.find('region');
    }
  }, {
    key: "script",
    value: function script() {
      return this.find('script');
    }

    /** @param {string} type */
  }, {
    key: "find",
    value: function find(type) {
      var i,
        l,
        subtag,
        subtags = this.subtags();
      for (i = 0, l = subtags.length; i < l; i++) {
        subtag = subtags[i];
        if (subtag.type() === type) {
          return subtag;
        }
      }
    }
  }, {
    key: "valid",
    value: function valid() {
      return this.errors().length < 1;
    }
  }, {
    key: "errors",
    value: function errors() {
      var error,
        subtags,
        data = this.data,
        errors = [];
      error = function error(code, subtag) {
        var err, message;
        switch (code) {
          case Tag.ERR_DEPRECATED:
            message = 'The tag \'' + data.tag + '\' is deprecated.';

            // Note that a record that contains a 'Deprecated' field and no corresponding 'Preferred-Value' field has no replacement mapping (RFC 5646 section 3.1.6).
            if (data.record['Preferred-Value']) {
              message += ' Use \'' + data.record['Preferred-Value'] + '\' instead.';
            }
            break;
          case Tag.ERR_SUBTAG_DEPRECATED:
            message = 'The subtag \'' + subtag + '\' is deprecated.';
            break;
          case Tag.ERR_NO_LANGUAGE:
            if (!data.tag) {
              message = 'Empty tag.';
            } else {
              message = 'Missing language tag in \'' + data.tag + '\'.';
            }
            break;
          case Tag.ERR_UNKNOWN:
            message = 'Unknown code \'' + subtag + '\'';
            break;
          case Tag.ERR_TOO_LONG:
            message = 'The priv